{"version":3,"sources":["../../src/internal/TouchRipple.js"],"names":["shift","newArray","TouchRipple","props","context","handleMouseDown","event","button","start","handleMouseUp","end","handleMouseLeave","handleTouchStart","stopPropagation","abortOnScroll","touches","startListeningForScrollAbort","startTime","Date","now","handleTouchEnd","handleTouchMove","timeSinceStart","Math","abs","stopListeningForScrollAbort","deltaY","clientY","firstTouchY","deltaX","clientX","firstTouchX","currentRipples","state","ripples","ripple","abortedRipple","cloneElement","aborted","setState","ignoreNextMouseDown","hasRipples","nextKey","isRippleTouchGenerated","theme","muiTheme","centerRipple","getRippleStyle","color","opacity","document","body","addEventListener","removeEventListener","el","findDOMNode","elHeight","offsetHeight","elWidth","offsetWidth","offset","isTouchEvent","length","pageX","pageY","pointerX","left","pointerY","top","topLeftDiag","calcDiag","topRightDiag","botRightDiag","botLeftDiag","rippleRadius","max","rippleSize","directionInvariant","height","width","a","b","sqrt","render","children","style","prepareStyles","rippleGroup","mergedStyles","position","overflow","pointerEvents","propTypes","bool","node","string","number","object","defaultProps","contextTypes","isRequired"],"mappings":"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","file":"TouchRipple.js","sourcesContent":["import React, {Component} from 'react';\nimport PropTypes from 'prop-types';\nimport ReactDOM from 'react-dom';\nimport ReactTransitionGroup from 'react-transition-group/TransitionGroup';\nimport Dom from '../utils/dom';\nimport CircleRipple from './CircleRipple';\n\n// Remove the first element of the array\nconst shift = ([, ...newArray]) => newArray;\n\nclass TouchRipple extends Component {\n  static propTypes = {\n    abortOnScroll: PropTypes.bool,\n    centerRipple: PropTypes.bool,\n    children: PropTypes.node,\n    color: PropTypes.string,\n    opacity: PropTypes.number,\n    style: PropTypes.object,\n  };\n\n  static defaultProps = {\n    abortOnScroll: true,\n  };\n\n  static contextTypes = {\n    muiTheme: PropTypes.object.isRequired,\n  };\n\n  constructor(props, context) {\n    super(props, context);\n    // Touch start produces a mouse down event for compat reasons. To avoid\n    // showing ripples twice we skip showing a ripple for the first mouse down\n    // after a touch start. Note we don't store ignoreNextMouseDown in this.state\n    // to avoid re-rendering when we change it.\n    this.ignoreNextMouseDown = false;\n\n    this.state = {\n      // This prop allows us to only render the ReactTransitionGroup\n      // on the first click of the component, making the inital render faster.\n      hasRipples: false,\n      nextKey: 0,\n      ripples: [],\n    };\n  }\n\n  start(event, isRippleTouchGenerated) {\n    const theme = this.context.muiTheme.ripple;\n\n    if (this.ignoreNextMouseDown && !isRippleTouchGenerated) {\n      this.ignoreNextMouseDown = false;\n      return;\n    }\n\n    let ripples = this.state.ripples;\n\n    // Add a ripple to the ripples array\n    ripples = [...ripples, (\n      <CircleRipple\n        key={this.state.nextKey}\n        style={!this.props.centerRipple ? this.getRippleStyle(event) : {}}\n        color={this.props.color || theme.color}\n        opacity={this.props.opacity}\n        touchGenerated={isRippleTouchGenerated}\n      />\n    )];\n\n    this.ignoreNextMouseDown = isRippleTouchGenerated;\n    this.setState({\n      hasRipples: true,\n      nextKey: this.state.nextKey + 1,\n      ripples: ripples,\n    });\n  }\n\n  end() {\n    const currentRipples = this.state.ripples;\n    this.setState({\n      ripples: shift(currentRipples),\n    });\n    if (this.props.abortOnScroll) {\n      this.stopListeningForScrollAbort();\n    }\n  }\n\n  handleMouseDown = (event) => {\n    // only listen to left clicks\n    if (event.button === 0) {\n      this.start(event, false);\n    }\n  };\n\n  handleMouseUp = () => {\n    this.end();\n  };\n\n  handleMouseLeave = () => {\n    this.end();\n  };\n\n  handleTouchStart = (event) => {\n    event.stopPropagation();\n    // If the user is swiping (not just tapping), save the position so we can\n    // abort ripples if the user appears to be scrolling.\n    if (this.props.abortOnScroll && event.touches) {\n      this.startListeningForScrollAbort(event);\n      this.startTime = Date.now();\n    }\n    this.start(event, true);\n  };\n\n  handleTouchEnd = () => {\n    this.end();\n  };\n\n  // Check if the user seems to be scrolling and abort the animation if so\n  handleTouchMove = (event) => {\n    // Stop trying to abort if we're already 300ms into the animation\n    const timeSinceStart = Math.abs(Date.now() - this.startTime);\n    if (timeSinceStart > 300) {\n      this.stopListeningForScrollAbort();\n      return;\n    }\n\n    // If the user is scrolling...\n    const deltaY = Math.abs(event.touches[0].clientY - this.firstTouchY);\n    const deltaX = Math.abs(event.touches[0].clientX - this.firstTouchX);\n    // Call it a scroll after an arbitrary 6px (feels reasonable in testing)\n    if (deltaY > 6 || deltaX > 6) {\n      let currentRipples = this.state.ripples;\n      const ripple = currentRipples[0];\n      // This clone will replace the ripple in ReactTransitionGroup with a\n      // version that will disappear immediately when removed from the DOM\n      const abortedRipple = React.cloneElement(ripple, {aborted: true});\n      // Remove the old ripple and replace it with the new updated one\n      currentRipples = shift(currentRipples);\n      currentRipples = [...currentRipples, abortedRipple];\n      this.setState({ripples: currentRipples}, () => {\n        // Call end after we've set the ripple to abort otherwise the setState\n        // in end() merges with this and the ripple abort fails\n        this.end();\n      });\n    }\n  };\n\n  startListeningForScrollAbort(event) {\n    this.firstTouchY = event.touches[0].clientY;\n    this.firstTouchX = event.touches[0].clientX;\n    // Note that when scolling Chrome throttles this event to every 200ms\n    // Also note we don't listen for scroll events directly as there's no general\n    // way to cover cases like scrolling within containers on the page\n    document.body.addEventListener('touchmove', this.handleTouchMove);\n  }\n\n  stopListeningForScrollAbort() {\n    document.body.removeEventListener('touchmove', this.handleTouchMove);\n  }\n\n  getRippleStyle(event) {\n    const el = ReactDOM.findDOMNode(this);\n    const elHeight = el.offsetHeight;\n    const elWidth = el.offsetWidth;\n    const offset = Dom.offset(el);\n    const isTouchEvent = event.touches && event.touches.length;\n    const pageX = isTouchEvent ? event.touches[0].pageX : event.pageX;\n    const pageY = isTouchEvent ? event.touches[0].pageY : event.pageY;\n    const pointerX = pageX - offset.left;\n    const pointerY = pageY - offset.top;\n    const topLeftDiag = this.calcDiag(pointerX, pointerY);\n    const topRightDiag = this.calcDiag(elWidth - pointerX, pointerY);\n    const botRightDiag = this.calcDiag(elWidth - pointerX, elHeight - pointerY);\n    const botLeftDiag = this.calcDiag(pointerX, elHeight - pointerY);\n    const rippleRadius = Math.max(\n      topLeftDiag, topRightDiag, botRightDiag, botLeftDiag\n    );\n    const rippleSize = rippleRadius * 2;\n    const left = pointerX - rippleRadius;\n    const top = pointerY - rippleRadius;\n\n    return {\n      directionInvariant: true,\n      height: rippleSize,\n      width: rippleSize,\n      top: top,\n      left: left,\n    };\n  }\n\n  calcDiag(a, b) {\n    return Math.sqrt((a * a) + (b * b));\n  }\n\n  render() {\n    const {children, style} = this.props;\n    const {hasRipples, ripples} = this.state;\n    const {prepareStyles} = this.context.muiTheme;\n\n    let rippleGroup;\n\n    if (hasRipples) {\n      const mergedStyles = Object.assign({\n        height: '100%',\n        width: '100%',\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        overflow: 'hidden',\n        pointerEvents: 'none',\n      }, style);\n\n      rippleGroup = (\n        <ReactTransitionGroup style={prepareStyles(mergedStyles)}>\n          {ripples}\n        </ReactTransitionGroup>\n      );\n    }\n\n    return (\n      <div\n        onMouseUp={this.handleMouseUp}\n        onMouseDown={this.handleMouseDown}\n        onMouseLeave={this.handleMouseLeave}\n        onTouchStart={this.handleTouchStart}\n        onTouchEnd={this.handleTouchEnd}\n      >\n        {rippleGroup}\n        {children}\n      </div>\n    );\n  }\n}\n\nexport default TouchRipple;\n"]}